<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Alice Shogi — 時空拡張（二盤・後手AI固定）</title>
<script src="https://cdn.tailwindcss.com"></script>
<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<style>
  .sq { width: clamp(32px, 9.5vw, 56px); height: clamp(32px, 9.5vw, 56px); }
  .no-select { -webkit-user-select:none; user-select:none; }
</style>
</head>
<body class="bg-amber-50 min-h-screen no-select">
<noscript style="color:#b91c1c;display:block;padding:8px">JavaScriptを有効にしてください。</noscript>
<div id="error" class="hidden bg-red-100 text-red-800 p-2 m-2 rounded text-xs"></div>
<div id="root" class="p-2"></div>
<script>
  window.addEventListener('error', (e) => {
    const box = document.getElementById('error');
    box.textContent = 'Runtime error: ' + (e.message || e.error);
    box.classList.remove('hidden');
  });
</script>

<script type="text/babel" data-presets="env,react">
const {useState,useMemo,useEffect} = React;

/* ===== 基本定義 ===== */
const S="S", G="G"; // 先手=Human / 後手=AI
const rows9=[...Array(9).keys()], cols9=[...Array(9).keys()];
const inB=(r,c)=>r>=0&&r<9&&c>=0&&c<9;
const otherB=id=>id==="A"?"B":"A";
const PROMO_ZONE={S:[0,1,2], G:[6,7,8]};
const PV={FU:100,KY:300,KE:300,GI:400,KI:500,KA:700,HI:800,OU:10000}; // AI評価

let NEXT_ID=1;
function makePiece(t, side, promoted=false){
  return { id: NEXT_ID++, t, side, promoted,
    ghost:0, lastMoved:-1, shadowGroup:null, delayedWarp:null
  };
}
const DISP={FU:"歩",KY:"香",KE:"桂",GI:"銀",KI:"金",KA:"角",HI:"飛",OU:"王",
            TO:"と",NY:"杏",NK:"圭",NG:"全",UM:"馬",RY:"龍"};
function dispOf(p){
  if(!p)return "";
  if(p.promoted){
    if(p.t==="FU")return DISP.TO;
    if(p.t==="KY")return DISP.NY;
    if(p.t==="KE")return DISP.NK;
    if(p.t==="GI")return DISP.NG;
    if(p.t==="KA")return DISP.UM;
    if(p.t==="HI")return DISP.RY;
  }
  return DISP[p.t];
}
const forward=side=>side===S?-1:+1;

function empty9(){return Array.from({length:9},()=>Array(9).fill(null));}
function initBoards(){
  const A=empty9(), B=empty9();
  // 後手（上）
  A[0][0]=makePiece("KY",G);A[0][1]=makePiece("KE",G);A[0][2]=makePiece("GI",G);A[0][3]=makePiece("KI",G);A[0][4]=makePiece("OU",G);A[0][5]=makePiece("KI",G);A[0][6]=makePiece("GI",G);A[0][7]=makePiece("KE",G);A[0][8]=makePiece("KY",G);
  A[1][1]=makePiece("KA",G);A[1][7]=makePiece("HI",G);
  for(let c=0;c<9;c++)A[2][c]=makePiece("FU",G);
  // 先手（下）
  for(let c=0;c<9;c++)A[6][c]=makePiece("FU",S);
  A[7][1]=makePiece("HI",S);A[7][7]=makePiece("KA",S);
  A[8][0]=makePiece("KY",S);A[8][1]=makePiece("KE",S);A[8][2]=makePiece("GI",S);A[8][3]=makePiece("KI",S);A[8][4]=makePiece("OU",S);A[8][5]=makePiece("KI",S);A[8][6]=makePiece("GI",S);A[8][7]=makePiece("KE",S);A[8][8]=makePiece("KY",S);
  return {A,B};
}
const cloneBoards = b => ({A:b.A.map(r=>r.slice()), B:b.B.map(r=>r.slice())});

/* ===== 同一盤の通常手 ===== */
function genMovesOne(boards, boardId, r, c){
  const p=boards[boardId][r][c]; if(!p)return[];
  const me=p.side, f=forward(me), M=[];
  const add=(rr,cc)=>{ if(!inB(rr,cc))return false; const t=boards[boardId][rr][cc];
    if(t&&t.side===me)return false; M.push({to:{r:rr,c:cc},capture:!!t}); return !t; };
  const slide=dirs=>{ for(const[dr,dc]of dirs){ let rr=r+dr,cc=c+dc; while(inB(rr,cc)){const cont=add(rr,cc); if(!cont)break; rr+=dr; cc+=dc;} } };
  const step=dirs=>dirs.forEach(([dr,dc])=>add(r+dr,c+dc));
  const goldS=[[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,0]];
  const goldG=[[1,-1],[1,0],[1,1],[0,-1],[0,1],[-1,0]];
  const t=p.t, pr=p.promoted;

  if(t==="FU"&&!pr){ add(r+f,c); }
  else if((t==="FU"||t==="KY"||t==="KE"||t==="GI")&&pr){ step(me===S?goldS:goldG); }
  else if(t==="KY"){ slide([[f,0]]); }
  else if(t==="KE"){ add(r+2*f,c-1); add(r+2*f,c+1); }
  else if(t==="GI"){ step(me===S?[[-1,-1],[-1,0],[-1,1],[1,-1],[1,1]]:[[1,-1],[1,0],[1,1],[-1,-1],[-1,1]]); }
  else if(t==="KI"){ step(me===S?goldS:goldG); }
  else if(t==="KA"){ slide([[-1,-1],[-1,1],[1,-1],[1,1]]); if(pr)step([[0,-1],[0,1],[-1,0],[1,0]]); }
  else if(t==="HI"){ slide([[-1,0],[1,0],[0,-1],[0,1]]); if(pr)step([[-1,-1],[-1,1],[1,-1],[1,1]]); }
  else if(t==="OU"){ step([[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]); }

  return M;
}

/* ===== 駒ごとのワープ仕様 ===== */
function warpOptionsForPiece(p, baseTo){
  const me=p.side, f=forward(me);
  if(p.t==="FU"&&!p.promoted) return {kind:"delay", options:[baseTo]};
  if(p.t==="KY"&&!p.promoted){ const opts=[]; for(let rr=0;rr<9;rr++)opts.push({r:rr,c:baseTo.c}); return {kind:"choose", options:opts}; }
  if(p.t==="KE"&&!p.promoted){ const opts=[{r:baseTo.r+2*f,c:baseTo.c-1},{r:baseTo.r+2*f,c:baseTo.c+1}].filter(s=>inB(s.r,s.c)); return {kind:"choose", options:opts.length?opts:[baseTo]}; }
  if(p.t==="GI"&&!p.promoted) return {kind:"instant", options:[baseTo], ghostTurns:1};
  if(p.t==="KI") return {kind:"clone_both", options:[baseTo]};
  if(p.t==="KA"){ const opts=[]; for(const[dr,dc]of[[-1,-1],[-1,1],[1,-1],[1,1]]){ let rr=baseTo.r+dr,cc=baseTo.c+dc; while(inB(rr,cc)){opts.push({r:rr,c:cc}); rr+=dr; cc+=dc;} } return {kind:"choose", options:opts.length?opts:[baseTo]}; }
  if(p.t==="HI"){ const opts=[]; for(let rr=0;rr<9;rr++)for(let cc=0;cc<9;cc++)opts.push({r:rr,c:cc}); return {kind:"choose", options:opts}; }
  if(p.t==="OU") return {kind:"clone_both", options:[baseTo]};
  return {kind:"instant", options:[baseTo]};
}

/* ===== UI ===== */
function Board({id,grid,collapsed,selected,targets,onClick,flip}){
  return (
    <div className="inline-block">
      <div className="grid grid-cols-9 border-4 border-amber-900 rounded-xl overflow-hidden shadow-xl">
        {rows9.map(r=>(
          <React.Fragment key={r}>
            {cols9.map(c=>{
              const rr=flip?8-r:r; const p=grid[rr][c]; const dark=(rr+c)%2===1;
              const sel=selected && selected.r===rr && selected.c===c;
              const tgt=targets.some(s=>s.r===rr&&s.c===c);
              const isCollapsed=collapsed.some(s=>s.r===rr&&s.c===c);
              return (
                <button key={c+':'+rr} onClick={()=>onClick(rr,c)}
                  className={`sq flex items-center justify-center text-base md:text-xl relative ${dark?'bg-amber-700/70':'bg-amber-200'} ${sel?'ring-4 ring-yellow-400':''} ${isCollapsed?'opacity-40 saturate-0':''}`}>
                  {tgt && <span className="absolute w-3 h-3 rounded-full bg-black/30" />}
                  {p && <span className={`${p.side===S?'text-black':'text-rose-900'} ${p.ghost?'opacity-60':''}`}>{dispOf(p)}</span>}
                </button>
              );
            })}
          </React.Fragment>
        ))}
      </div>
    </div>
  );
}

/* ===== アプリ本体（後手AI固定） ===== */
function App(){
  const [boards,setBoards]=useState(initBoards());
  const [turn,setTurn]=useState(S);                 // あなた=先手
  const [selected,setSelected]=useState(null);
  const [targets,setTargets]=useState([]);
  const [flip,setFlip]=useState(false);
  const [history,setHistory]=useState([]);
  const [collapse,setCollapse]=useState([{sq:randSq(),remain:3}]); // {sq:{r,c},remain}
  const [respawns,setRespawns]=useState([]); // {piece,board,sq,due}
  const [needWarp,setNeedWarp]=useState(null); // Human用選択
  const [promoAsk,setPromoAsk]=useState(null); // Human用選択
  const [turnNo,setTurnNo]=useState(1);

  const collapsedCoords = useMemo(()=>collapse.map(x=>x.sq),[collapse]);

  // ==== 共通ユーティリティ ====
  function randSq(){ return {r:Math.floor(Math.random()*9), c:Math.floor(Math.random()*9)}; }
  const deep = b => cloneBoards(b);
  const inPromo = (side,r)=>PROMO_ZONE[side].includes(r);

  function legalMovesOn(boardId,r,c){
    const p=boards[boardId][r][c]; if(!p || p.side!==turn) return [];
    return genMovesOne(boards,boardId,r,c).filter(m=>!collapsedCoords.some(s=>s.r===m.to.r&&s.c===m.to.c));
  }

  function onSquareClick(boardId,r,c){
    if(turn===G) return; // 後手AIの手番は操作不可
    if(needWarp||promoAsk) return;
    if(selected && selected.board===boardId){
      const found=legalMovesOn(boardId,selected.r,selected.c).find(m=>m.to.r===r&&m.to.c===c);
      if(found) return doMoveHuman(boardId,selected.r,selected.c,found.to);
    }
    const p=boards[boardId][r][c];
    if(p && p.side===turn){ setSelected({board:boardId,r,c}); setTargets(legalMovesOn(boardId,r,c).map(m=>m.to)); }
    else { setSelected(null); setTargets([]); }
  }

  // ==== Human move ====
  function doMoveHuman(boardId,r,c,to){
    const b=deep(boards); const p=b[boardId][r][c]; if(!p)return;
    b[boardId][r][c]=null; b[boardId][to.r][to.c]=p;
    const canProm = (["FU","KY","KE","GI","KA","HI"].includes(p.t) && (inPromo(p.side,to.r)||inPromo(p.side,r))) && !p.promoted;
    if(canProm){ setBoards(b); setPromoAsk({board:boardId,r:to.r,c:to.c,pieceId:p.id}); setSelected(null); setTargets([]); return; }
    setBoards(b); afterMoveCommon({board:boardId,to}, false, false);
  }

  function confirmPromotion(yes){
    if(!promoAsk) return;
    const {board,r,c,pieceId}=promoAsk;
    const b=deep(boards); let p=b[board][r][c];
    if(p && p.id===pieceId && yes){
      p.promoted=true;
      // 時空昇格コピー：相手盤同座標が空なら生成
      const ob=otherB(board);
      if(!b[ob][r][c]){ b[ob][r][c]=makePiece(p.t,p.side,true); }
    }
    setBoards(b); setPromoAsk(null);
    afterMoveCommon({board,to:{r,c}}, yes, false);
  }

  /* ---- 移動後：ワープ処理＋ターン進行共通 ---- */
  function afterMoveCommon(ctx, _autoPromoted, isAI){
    const {board,to}=ctx; const b=boards; const p=b[board][to.r][to.c]; const ob=otherB(board);
    const warp=warpOptionsForPiece(p,to);
    const valid = warp.options.filter(s=>inB(s.r,s.c)).filter(s=>{
      const tgt=b[ob][s.r][s.c]; return (!tgt || tgt.side!==p.side);
    }).filter(s=>!collapsedCoords.some(x=>x.r===s.r&&x.c===s.c));

    if(warp.kind==="delay"){ p.delayedWarp={baseTo:to}; return endTurn(`${dispOf(p)} ${board} r${to.r+1}c${to.c+1}：遅延ワープ待機`); }
    if(valid.length===0){ alert("ワープ先が塞がれました"); return; }

    if(warp.kind==="choose"){
      if(isAI){
        return applyWarpFinish(p,board,to,ob,valid[0],{ghost:warp.ghostTurns||0,clone:false});
      } else {
        setNeedWarp({pieceId:p.id, fromBoard:board, baseTo:to, options:valid, ghostTurns:warp.ghostTurns||0});
        return;
      }
    }
    if(warp.kind==="clone_both"){
      return applyWarpFinish(p,board,to,ob,valid[0],{ghost:0,clone:true});
    }
    return applyWarpFinish(p,board,to,ob,valid[0],{ghost:warp.ghostTurns||0,clone:false});
  }

  function chooseWarpDest(sq){
    if(!needWarp) return;
    const {pieceId,fromBoard,baseTo,ghostTurns}=needWarp;
    const p=boards[fromBoard][baseTo.r][baseTo.c];
    if(!p || p.id!==pieceId){ setNeedWarp(null); return; }
    applyWarpFinish(p,fromBoard,baseTo,otherB(fromBoard),sq,{ghost:ghostTurns,clone:false});
    setNeedWarp(null);
  }

  function applyWarpFinish
